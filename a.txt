# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    a.txt                                              :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: sakdil < sakdil@student.42istanbul.com.    +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/08/08 14:10:05 by sakdil            #+#    #+#              #
#    Updated: 2025/08/08 22:38:32 by sakdil           ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

#include "philo.h"

size_t ft_strlen(const char *s)
{
    int i;
    
    i = 0;
    while (s[i])
        i++;
    return i;
}

int ft_atoi(const char *str)
{
    int i;
    int res;
    
    i = 0;
    res = 0;
    while ((str[i] >= 9 && str[i] <= 13) || str[i] == ' ')
        i++;
    if (str[i] == '-' || str[i] == '+')
        return (-1);
    while (str[i] >= '0' && str[i] <= '9')
    {
        res = (res * 10) + (str[i] - '0');
        i++;
    }
    if (res > INT_MAX)
    {
        return (-1);
    }
    return (res);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cleanup.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sakdil < sakdil@student.42istanbul.com.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/08 14:10:53 by sakdil            #+#    #+#             */
/*   Updated: 2025/08/08 22:26:26 by sakdil           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "philo.h"

void free_sim(t_sim *sim)
{
    int i;

    i = 0;
    if (!sim)
        return;
    if (sim->forks.forks)
        free(sim->forks.forks);
    if (sim->philos)
    {
        while (i < sim->rules.count)
        {
            if (sim->philos[i])
                free(sim->philos[i]);
            i++;
        }
        free(sim->philos);
    }
    free(sim);
}

void destroy_mutexes(t_sim *sim)
{
    int i;

    i = 0;
    while (i < sim->rules.count)
    {
        pthread_mutex_destroy(&sim->forks.forks[i]);
        pthread_mutex_destroy(&sim->philos[i]->eat_lock);
        i++;
    }
    pthread_mutex_destroy(&sim->control.print_lock);
    pthread_mutex_destroy(&sim->control.stop_lock);
}

int print_error(char *msg)
{
    write(2, msg, ft_strlen(msg));
    return (1);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sakdil < sakdil@student.42istanbul.com.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/08 14:11:21 by sakdil            #+#    #+#             */
/*   Updated: 2025/08/08 14:11:21 by sakdil           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "philo.h"

static int only_digits(char *str)
{
    int i;

	i = 0;
    while (str[i])
    {
        if (str[i] < '0' || str[i] > '9')
            return (0);
        i++;
    }
    return (1);
}
/// @ef ///////////////////////////////////////////////////////////
/// param sim 

static void set_start_time(t_sim *sim)
{
    if (!sim)
        return ;
    sim->start_time = ft_get_time_in_ms() + (sim->rules.count * 2 * 10);
}

static int create_philos(t_sim *sim)
{
    int i;

	i = 0;
    if (!sim || !sim->philos)
        return (0);
    while (i < sim->rules.count)
    {
        if (pthread_create(&sim->philos[i]->thread, NULL, ft_philo,
							sim->philos[i]) != 0)
            return (0);
		i++;
    }
    return (1);
}

static int create_thread(t_sim *sim)
{
    if (!sim)
        return (0);
    if (sim->rules.count <= 1)
        return (1);
    if (pthread_create(&sim->monitor, NULL, controller_loop, sim) != 0)
        return (0);
    return (1);
}

static int start_simulation(t_sim *sim)
{
    if (!sim)
        return (print_error("Error: sim is NULL\n"), 0);
    set_start_time(sim);
    if (!create_philos(sim))
        return (print_error("Error: failed to create philosopher threads\n"), false);
    if (!create_thread(sim))
        return (print_error("Error: failed to create monitor thread\n"), false);
    return (1);
}
/// @ef ///////////////////////////////////////////////////////////
/// param sim 
static void stop_simulation(t_sim *sim)
{
    int i;

	i = 0;
    while (i < sim->rules.count)
    {
        pthread_join(sim->philos[i]->thread, NULL);
        i++;
    }
    if (sim->rules.count > 1)
        pthread_join(sim->monitor, NULL);
    destroy_mutexes(sim);
    free_sim(sim);
}

static int run_simulation(int argc, char **argv)
{
    t_sim *sim;

    sim = init_sim(argc, argv, 1);
    if (!sim)
        return (print_error("Error: simulation initialization failed\n"), 1);
    if (!start_simulation(sim))
    {
        free_sim(sim);
        return (print_error("Error: thread creation failed\n"), 1);
    }
    stop_simulation(sim);
    return (0);
}

int main(int argc, char **argv)
{
    int i;

    i = 1;
    if (argc != 5 && argc != 6)
        return (print_error("Error: wrong number of arguments\n"));
    while (i < argc)
    {
        if (!only_digits(argv[i]))
            return (print_error("Error: arguments must be positive numbers\n"));
        if (ft_atoi(argv[i]) == -1)
            return (print_error("Error: invalid or too large argument\n"));
        i++;
    }
    if (ft_atoi(argv[1]) <= 0 || ft_atoi(argv[1]) > 200 || ft_atoi(argv[2]) <= 0
        || ft_atoi(argv[3]) <= 0 || ft_atoi(argv[4]) <= 0
        || (argc == 6 && ft_atoi(argv[5]) <= 0))
        return (print_error("Error: arguments must be positive and within limits\n"));
    return (run_simulation(argc, argv));
}
SRCS	=	cleanup.c		\
			check.c			\
			monitor.c		\
			main.c			\
			setup.c			\
			routine.c		\
			report.c		\
			time.c			\

OBJS	=	$(SRCS:.c=.o)
RM		=	rm -f
CFLAGS	=	-Wall -Wextra -Werror
CC 		= 	cc
NAME	=	philo

all: $(NAME)

$(NAME): $(OBJS)
	$(CC) $(CFLAGS) $(OBJS) -o $(NAME) -pthread

clean:
	$(RM) $(OBJS)

fclean: clean
	$(RM) $(NAME)

re: fclean all

.PHONY: all clean fclean re

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   monitor.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sakdil < sakdil@student.42istanbul.com.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/08 14:11:46 by sakdil            #+#    #+#             */
/*   Updated: 2025/08/08 14:11:46 by sakdil           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "philo.h"

static void ft_set_routine_stop_flag(t_sim *sim, bool f_state)
{
    pthread_mutex_lock(&sim->control.stop_lock);
    sim->control.stop = f_state;
    pthread_mutex_unlock(&sim->control.stop_lock);
}

bool ft_has_routine_stopped(t_sim *sim)
{
    bool r;

    r = false;
    pthread_mutex_lock(&sim->control.stop_lock);
    if (sim->control.stop)
        r = true;
    pthread_mutex_unlock(&sim->control.stop_lock);
    return (r);
}

static bool ft_kill_philo(t_philo *philo)
{
    time_t time;

    time = ft_get_time_in_ms();
    if ((time - philo->last_meal) >= philo->sim->rules.die_time)
    {
        pthread_mutex_unlock(&philo->eat_lock);
        ft_write_status(philo, "died");
        ft_set_routine_stop_flag(philo->sim, true);
        return (true);
    }
    return (false);
}

static bool ft_end_condition_reached(t_sim *sim)
{
    int i;
    bool         all_ate_enough;

    i = 0;
    all_ate_enough = true;
    while (i < sim->rules.count)
    {
        pthread_mutex_lock(&sim->philos[i]->eat_lock);
        if (ft_kill_philo(sim->philos[i]))
            return true;
        if (sim->rules.has_limit)
            if (sim->philos[i]->eat_count < sim->rules.must_eat)
                all_ate_enough = false;
        pthread_mutex_unlock(&sim->philos[i]->eat_lock);
        i++;
    }
    if (sim->rules.has_limit && all_ate_enough)
    {
        ft_set_routine_stop_flag(sim, true);
        return (true);
    }
    return (false);
}

void *controller_loop(void *data)
{
    t_sim *sim;

    sim = (t_sim *)data;
    if (sim->rules.must_eat == 0)
        return (NULL);
    ft_set_routine_stop_flag(sim, false);
    ft_routine_start_delay(sim->start_time);
    while (true)
    {
        if (ft_end_condition_reached(sim))
            return NULL;
        usleep(1000);
    }
    return (NULL);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   philo.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sakdil < sakdil@student.42istanbul.com.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/08 09:25:04 by sakdil            #+#    #+#             */
/*   Updated: 2025/08/08 14:11:07 by sakdil           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef PHILO_H
# define PHILO_H

# include <pthread.h>
# include <sys/time.h>
# include <stdbool.h>
# include <limits.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

typedef struct s_rules
{
    int     count;
    long    die_time;
    long    eat_time;
    long    sleep_time;
    int     must_eat;
    bool    has_limit;
} t_rules;

typedef struct s_forks
{
    pthread_mutex_t *forks;
} t_forks;

typedef struct s_control
{
    bool            stop;
    pthread_mutex_t stop_lock;
    pthread_mutex_t print_lock;
} t_control;

typedef struct s_philo t_philo;

typedef struct s_sim
{
    t_rules         rules;
    t_control       control;
    t_forks         forks;
    t_philo         **philos;
    long            start_time;
    pthread_t       monitor;
} t_sim;

struct s_philo
{
    int             id;
    int             eat_count;
    long            last_meal;
    pthread_t       thread;
    pthread_mutex_t eat_lock;
    t_sim           *sim;
};

int             ft_atoi(const char *str);
size_t          ft_strlen(const char *s);

int ft_set_rules(t_rules *rules, int ac, char **av);
t_sim           *init_sim(int ac, char **av, int i);
bool            ft_init_forks(t_sim *sim);
bool            init_philos(t_sim *sim);
char            *ft_format_status(t_philo *philo, char *str);

void            *ft_philo(void *data);

time_t          ft_get_time_in_ms(void);
void            ft_philo_sleep(t_sim *sim, time_t sleep_time);
void            ft_routine_start_delay(time_t start_time);

void            ft_write_status(t_philo *philo, char *str);
int             print_error(char *msg);

void            *controller_loop(void *data);
bool            ft_has_routine_stopped(t_sim *sim);

void            free_sim(t_sim *sim);
void            destroy_mutexes(t_sim *sim);

#endif

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   report.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sakdil < sakdil@student.42istanbul.com.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/08 14:12:21 by sakdil            #+#    #+#             */
/*   Updated: 2025/08/08 14:12:21 by sakdil           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "philo.h"


char *ft_format_status(t_philo *philo, char *str)
{
    char *buffer;
    char time_str[32];

    sprintf(time_str, "%ld %d %s\n", ft_get_time_in_ms() - philo->sim->start_time,
            philo->id + 1, str);
    buffer = malloc(ft_strlen(time_str) + 1);
    if (!buffer)
        return (NULL);
    sprintf(buffer, "%s", time_str);
    return (buffer);
}

void ft_write_status(t_philo *philo, char *str)
{
    char *formatted;

    pthread_mutex_lock(&philo->sim->control.print_lock);

    // Eğer rutin durduysa, yazdırma işlemi yapma
    if (ft_has_routine_stopped(philo->sim))
    {
        pthread_mutex_unlock(&philo->sim->control.print_lock);
        return;
    }

    // Durum mesajını formatla
    formatted = ft_format_status(philo, str);

    // Eğer formatlama başarılıysa, mesajı yazdır
    if (formatted)
    {
        printf("%s", formatted);
        free(formatted);
    }

    pthread_mutex_unlock(&philo->sim->control.print_lock);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   routine.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sakdil < sakdil@student.42istanbul.com.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/08 14:13:17 by sakdil            #+#    #+#             */
/*   Updated: 2025/08/08 14:13:17 by sakdil           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "philo.h"

static void ft_eat_sleep_routine(t_philo *philo)
{
    int fork1;
    int fork2;

    fork1 = philo->id;
    fork2 = (philo->id + 1) % philo->sim->rules.count;
    if (philo->id % 2)
    {
        fork1 = (philo->id + 1) % philo->sim->rules.count;
        fork2 = philo->id;
    }
    pthread_mutex_lock(&philo->sim->forks.forks[fork1]);
    ft_write_status(philo, "has taken a fork");
    pthread_mutex_lock(&philo->sim->forks.forks[fork2]);
    ft_write_status(philo, "has taken a fork");
    ft_write_status(philo, "is eating");
    pthread_mutex_lock(&philo->eat_lock);
    philo->last_meal = ft_get_time_in_ms();
    pthread_mutex_unlock(&philo->eat_lock);
    ft_philo_sleep(philo->sim, philo->sim->rules.eat_time);
    if (!ft_has_routine_stopped(philo->sim))
    {
        pthread_mutex_lock(&philo->eat_lock);
        philo->eat_count += 1;
        pthread_mutex_unlock(&philo->eat_lock);
    }
    ft_write_status(philo, "is sleeping");
    pthread_mutex_unlock(&philo->sim->forks.forks[fork2]);
    pthread_mutex_unlock(&philo->sim->forks.forks[fork1]);
    ft_philo_sleep(philo->sim, philo->sim->rules.sleep_time);
}

static void ft_think_routine(t_philo *philo, bool silent)
{
    time_t time_to_think;

    pthread_mutex_lock(&philo->eat_lock);
    time_to_think = (philo->sim->rules.die_time
                     - (ft_get_time_in_ms() - philo->last_meal)
                     - philo->sim->rules.eat_time) / 2;
    pthread_mutex_unlock(&philo->eat_lock);
    if (time_to_think < 0)
        time_to_think = 0;
    if (time_to_think == 0 && silent)
        time_to_think = 1;
    if (time_to_think > 600)
        time_to_think = 200;
    if (!silent)
        ft_write_status(philo, "is thinking");
    ft_philo_sleep(philo->sim, time_to_think);
}

static void *ft_alone_philo_routine(t_philo *philo)
{
    int fork1;
    
    fork1 = philo->id;
    pthread_mutex_lock(&philo->sim->forks.forks[fork1]);
    ft_write_status(philo, "has taken a fork");
    ft_philo_sleep(philo->sim, philo->sim->rules.die_time);
    ft_write_status(philo, "died");
    pthread_mutex_unlock(&philo->sim->forks.forks[fork1]);
    return NULL;
}

void *ft_philo(void *data)
{
    t_philo *philo;
    
    philo = (t_philo *)data;
    if (philo->sim->rules.must_eat == 0)
        return NULL;
    pthread_mutex_lock(&philo->eat_lock);
    philo->last_meal = philo->sim->start_time;
    pthread_mutex_unlock(&philo->eat_lock);
    ft_routine_start_delay(philo->sim->start_time);
    if (philo->sim->rules.die_time == 0)
        return NULL;
    if (philo->sim->rules.count == 1)
        return ft_alone_philo_routine(philo);
    else if (philo->id % 2)
        ft_think_routine(philo, true);
    while (!ft_has_routine_stopped(philo->sim))
    {
        ft_eat_sleep_routine(philo);
        ft_think_routine(philo, false);
    }
    return (NULL);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   setup.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sakdil < sakdil@student.42istanbul.com.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/08 14:13:34 by sakdil            #+#    #+#             */
/*   Updated: 2025/08/08 14:13:34 by sakdil           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "philo.h"

int ft_set_rules(t_rules *rules, int argc, char **argv)
{
    rules->count = ft_atoi(argv[0]);
    if (rules->count == -1)
        return (print_error("Error: invalid philosopher count\n"), 0);
    rules->die_time = ft_atoi(argv[1]);
    if (rules->die_time == -1)
        return (print_error("Error: invalid time to die\n"), 0);
    rules->eat_time = ft_atoi(argv[2]);
    if (rules->eat_time == -1)
        return (print_error("Error: invalid time to eat\n"), 0);
    rules->sleep_time = ft_atoi(argv[3]);
    if (rules->sleep_time == -1)
        return (print_error("Error: invalid time to sleep\n"), 0);
    rules->must_eat = -1;
    rules->has_limit = false;
    if (argc == 6)
    {
        rules->must_eat = ft_atoi(argv[4]);
        if (rules->must_eat == -1)
            return (print_error("Error: invalid meal limit\n"), 0);
        rules->has_limit = true;
    }
    return (1);
}

bool ft_init_forks(t_sim *sim)
{
    int i;

    i = 0;
    sim->forks.forks = malloc(sizeof(pthread_mutex_t) * sim->rules.count);
    if (!sim->forks.forks)
        return (print_error("Error: memory allocation for forks failed\n"), false);
    while (i < sim->rules.count)
    {
        if (pthread_mutex_init(&sim->forks.forks[i], NULL) != 0)
        {
            while (i > 0)
            {
                i--;
                pthread_mutex_destroy(&sim->forks.forks[i]);
            }
            free(sim->forks.forks);
            sim->forks.forks = NULL;
            return (print_error("Error: fork mutex initialization failed\n"), false);
        }
        i++;
    }
    return (true);
}

static void cleanup_philos(t_sim *sim, int n)
{
    while (n > 0)
    {
        pthread_mutex_destroy(&sim->philos[n]->eat_lock);
        free(sim->philos[n]);
        n--;
    }
    free(sim->philos);
    sim->philos = NULL;
}

bool init_philos(t_sim *sim)
{
    int i;

    i = 0;
    sim->philos = malloc(sizeof(*sim->philos) * sim->rules.count);
    if (!sim->philos)
        return (print_error("Error: malloc philosophers\n"), false);
    while (i < sim->rules.count)
    {
        sim->philos[i] = malloc(sizeof(*sim->philos[i]));
        if (!sim->philos[i]
         || pthread_mutex_init(&sim->philos[i]->eat_lock, NULL))
            break;
        sim->philos[i]->sim        = sim;
        sim->philos[i]->id         = i;
        sim->philos[i]->last_meal  = 0;
        sim->philos[i]->eat_count  = 0;
        i++;
    }
    if (i < sim->rules.count)
    {
        cleanup_philos(sim, i);
        print_error("Error: init philosophers\n");
        return (false);
    }
    return (true);
}

static int init_mutex(t_sim *sim)
{
    if (pthread_mutex_init(&sim->control.stop_lock, NULL) != 0)
    {
        free_sim(sim);
        return (print_error("Error: stop mutex initialization failed\n"), 0);
    }
    if (pthread_mutex_init(&sim->control.print_lock, NULL) != 0)
    {
        free_sim(sim);
        return (print_error("Error: print mutex initialization failed\n"), 0);
    }
    return (1);
}

t_sim *init_sim(int argc, char **argv, int i)
{
    t_sim *sim;

    sim = malloc(sizeof(t_sim));
    if (!sim)
        return (print_error("Error: memory allocation for simulation failed\n"), NULL);
    if (!ft_set_rules(&sim->rules, argc, &argv[i]))
    {
        free(sim);
        return (NULL);
    }
    if (!ft_init_forks(sim) || !init_philos(sim))
    {
        free(sim);
        return (NULL);
    }
    if (!init_mutex(sim))
        return (NULL);
    sim->control.stop = false;
    return (sim);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   time.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sakdil < sakdil@student.42istanbul.com.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/08 14:13:52 by sakdil            #+#    #+#             */
/*   Updated: 2025/08/08 19:16:32 by sakdil           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "philo.h"

time_t ft_get_time_in_ms(void)
{
    struct timeval tv;

    gettimeofday(&tv, NULL);
    return ((tv.tv_sec * 1000) + (tv.tv_usec / 1000));
}

void ft_philo_sleep(t_sim *sim, time_t sleep_time)
{
    time_t wake_up;

    wake_up = ft_get_time_in_ms() + sleep_time;
    while (ft_get_time_in_ms() < wake_up)
    {
        if (ft_has_routine_stopped(sim))
            break;
        usleep(100);
    }
}

void ft_routine_start_delay(time_t start_time)
{
    while (ft_get_time_in_ms() < start_time)
        usleep(10);
}
